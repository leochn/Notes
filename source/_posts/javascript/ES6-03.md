---
title: ES6-03
date: 2017-07-16 19:02:01
tags: es6
---
es6 的一些特性学习
<!-- more -->
## 复制数组
### 复制数组-循环
```js
    var arr=[1,2,3];
    var arr2=[];
    for(var i=0; i<arr.length; i++){
        arr2[i]=arr[i];
    }
    arr2.pop();
    console.log(arr, arr2);
```

### 复制数组-Array.from(arr)
```js
    var arr=[1,2,3];
    var arr2=Array.from(arr);
    arr2.pop();
    console.log(arr, arr2)
```

### 复制数组-var arr2=[...arr]; (... 超引用)
```js
    var arr=[1,2,3];
    var arr2=[...arr];
    arr2.pop();
    console.log(arr, arr2);
```

### 赋值数组-...示例 (... 超引用)
```js
    function show(){
        console.log(arguments);
        arguments.push(5); // Uncaught TypeError: arguments.push is not a function
        console.log(arguments);
    }
    show(1,2,3,4);
```

```js
    function show(...args){
        args.push(5);
        console.log(args);
    }
    show(1,2,3,4); // Array(5)
```

## 循环
### for in (可以循环数组,json)
```js
    var arr=['apple','banana','orange','pear'];
    for(var i in arr){ 
        console.log(i); // 0 1 2 3  索引值
    }
```

```js
    var json={'a':'apple','b':'banan','c':'pear','d':'orange'};
    for(var name in json){
        console.log(name); // a b c d 
    }
```

### for of (可以循环数组,不能循环json)
```js
    var arr=['apple','banana','orange','pear'];
    for(var i of arr){  
        console.log(i); // apple banana orange pear  值
    }
```

```js
    var json={'a':'apple','b':'banan','c':'pear','d':'orange'};
    for(var name of json){
       console.log(name);  // Uncaught TypeError: json[Symbol.iterator] is not a function
    }
```

## Map对象
Map对象和json相似,也是一种key-value形式.Map对象为了和for of循环配合而生的.

### new Map();
```js
    var map=new Map();
    //map.set(name,value);     // 设置Map
    map.set('a','apple');
    map.set('b','banana');
    console.log(map);          // Map(2)
    console.log(map['a']);     // undefined
    console.log(map.get('b')); // banana
    map.delete('a');           // 删除Map
    console.log(map);          // Map(2)
```

### 遍历map (不能使用for in,没有效果)
```js
    var map=new Map();
    map.set('a','apple');
    map.set('b','banana');
    map.set('c','orange');
    map.set('d','pear');
    for(var name of map){
        console.log(name); 
        // a,apple  
        // b,banana  
        // ...
    }
    for(var [key,value] of map){
        console.log(key, value);
        // a apple
        // b banana
        // ......
    }
    for(var [a,b] of map.entries()){
        console.log(a,b);
        // a apple
        // b banana
        // ......
    }
    for(var key of map.keys()){      //只是循环key
        console.log(key);
    }

    for(var val of map.values()){    //只是循环value
        console.log(val);
    }
```

### for... of也可以循环数组
```
    只循环值:
        for(var value of arr){}
    只循环索引:
        for(var key of arr.keys()){}
    索引和值都循环：
        for(var some of arr.entries()){}
```

## 箭头函数
```
原来写法                    箭头函数 =>
var show=a=>a;              function show(a){return a};
    
var show=(a,b)=>a+b;        function show(a,b){return a+b};

var show=()=>'welcome';     function show(){return 'welcome'}

var show=() => {            function show(){
    alert(1);                   alert(1);
}                           }
```

### 箭头函数-应用
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        #box{
            width:100px;
            height:100px;
            background: #ccc;
        }
    </style>
    <script>
        window.onload=()=>{
            var oBox=document.getElementById('box');

            oBox.onclick=()=>{
                oBox.style.background='red';
            };
        };
    </script>
</head>
<body>
    <div id="box"></div>
</body>
</html>
```

### 箭头函数-注意
this问题,this指向了window.
arguments,不能使用了.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script>
        var a=101;
        var json={
            a:1,
            b:2,
            show:()=>{
               console.log(this.a);  // 101
            }
        };
        json.show();
    </script>
</head>
<body>
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script>
        function show(){
            console.log(arguments); // Arguments(3)
        }
        show(1,2,3);
        var show=()=>{
            console.log(arguments); //Uncaught ReferenceError: arguments is not defined
        };
        show(1,2,3);
    </script>
</head>
<body>
</body>
</html>
```

## 对象
对象语法简洁化
单体模式


## 面向对象
### 之前类的写法
```js
    function Person(name,age){  //类、构造函数
        this.name=name;
        this.age=age;
    }
    Person.prototype.showName=function(){
        return this.name;
    };
    Person.prototype.showAge=function(){
        return this.age;
    };
    var p1=new Person('abc',10);
    alert(p1.showName()); //abc
```
### ES6写法
```js
    //构造函数    constructor 生成完实例以后，自己就执行的
    class Person{   //类
        constructor(name,age){
            this.name=name;
            this.age=age;
        }
        showName(){
            return this.name;
        }
        showAge(){
            return this.age;
        }
    }
    var p1=new Person('aaa',10);
    alert(p1.name);    // aaa
```

### 面向对象-函数给默认值
```js
    function move(obj='对象必须要填写的',json={},options){
        console.log(obj);     // 对象必须要填写的
        console.log(json);    // Object {}
        console.log(options); // undefined
    }
    move();
```

### 面向对象-继承
```js
    // 之前写法: 子类.prototype=new 父类();
    //Person
    function Person(name,age){
        this.name=name;
        this.age=age;
    }
    Person.prototype.showName=function(){
        return this.name;
    };
    Person.prototype.showAge=function(){
        return this.age;
    };

    //Worker
    function Worker(name,age){
        Person.apply(this,arguments);
    }
    Worker.prototype=new Person();

    var p1=new Person('abc',10);
    var w1=new Person('ddd',20);
    alert(p1.showName()); //abc
    alert(w1.showName()); //ddd
```

```js
    //ES6写法: 
     class Person{ //类
        constructor(name='default',age=0){
            this.name=name;
            this.age=age;
        }
        showName(){
            return this.name;
        }
        showAge(){
            return this.age;
        }
    }
    //继承
    class Worker extends Person{
        constructor(name,age,job='Worker -> 撸码的...'){
            super(name,age); //调用父级构造
            this.job=job;
        }
        showJob(){
            return this.job;
        }
    }
    var p1=new Person();
    var w1=new Worker('mmm',56);
    alert(p1.showAge());   // 0
    alert(w1.showName());  // mmm
    alert(w1.job);         // Worker -> 撸码的...
```
### 面向对象-队列类
``` js
    class Queue{
        constructor(content=[]){
            this._queue=[...content];
        }
    }
    var q=new Queue([1,2,3,4]);
    console.log(q._queue);  // 1 2 3 4
```

```js
    class Queue{
        constructor(content=[]){
            this._queue=[...content];
        }
        shift(){
            // 删除数组的第一个元素
            const value=this._queue[0];
            this._queue.shift();
            return value;
        }
        push(n){
            this._queue.push(n);
            return this._queue.length;
        }
    }
    var q=new Queue([1,2,3,4]);
    var s = q.shift();  
    console.log(s);          // 1
    q.push(9);
    console.log(q._queue);   // 2 3 4 9
    q.shift();
    console.log(q._queue);   // 3 4 9
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        .on{ background: #f60; color: #fff}
        .box div{
            width:200px;
            height:200px;
            border: 1px solid #000;
            display: none;
        }
    </style>
    <script>
        //选项卡
        class Tab{
            constructor(id){
                this.oBox=document.getElementById(id);
                this.aBtn=this.oBox.getElementsByTagName('input');
                this.aDiv=this.oBox.getElementsByTagName('div');
                this.iNow=0;
                this.init();
            }
            init(){
                for(let i=0; i<this.aBtn.length; i++){
                    this.aBtn[i].onclick=function(){
                        this.iNow=i;
                        this.hide();
                        this.show(i);
                        document.title=this.iNow;
                    }.bind(this); // bind 矫正this的指向
                }
            }
            hide(){
                for(let i=0; i<this.aBtn.length; i++){
                    this.aBtn[i].className='';
                    this.aDiv[i].style.display='none';
                }
            }
            show(index){
                this.aBtn[index].className='on';
                this.aDiv[index].style.display='block';
            }
        }
        //继承
        class AutoTab extends Tab{
            next(){
                this.iNow++;
                if(this.iNow==this.aBtn.length)this.iNow=0;
                this.hide();
                this.show(this.iNow);
            }
        }
        window.onload=function(){
            new Tab('box');
            var at=new AutoTab('box2');

            document.onclick=function(){
                at.next();
            };
        };
    </script>
</head>
<body>
    <div id="box" class="box">
        <input class="on" type="button" value="aaa">
        <input type="button" value="bbb">
        <input type="button" value="ccc">
        <div style="display: block;">1111</div>
        <div>2222</div>
        <div>3333</div>
    </div>
    <div id="box2" class="box">
        <input class="on" type="button" value="aaa">
        <input type="button" value="bbb">
        <input type="button" value="ccc">
        <div style="display: block;">1111</div>
        <div>2222</div>
        <div>3333</div>
    </div>
</body>
</html>
```

## 模块化(ES6自带模块化
### 如何定义(导出)模块
a.js
```js
    const a=12;
    export default a;
```

b.js
```js
    const a=5;
    export default a;
```

导出多个模块
```js
    const a=5;
    const b=12;
    export default {a,b};
```
### 如何使用(引用))
demo.js
```js
    import modA from './a.js';
    import modB from './b.js';
    console.log(modA+modB);  // 17
```

## Promise -> 承诺
就是一个对象,用来传递异步操作的数据(消息).
pending(等待、处理中) ―> Resolve(完成、fullFilled) ―> Rejected(拒绝、失败).

###
```js
    var p1 = new Promise(function(resolve, reject) {
        resolve(1);
    });
    p1.then(function(value) {
        alert('成功了:' + value);
    }, function() {
        alert('失败了');
    });
```

## Generrator -> 生成器